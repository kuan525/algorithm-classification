题面：

> [codeforce](https://codeforces.com/problemsets/acmsguru/problem/793/D)   [daimayuan](http://oj.daimayuan.top/course/10/problem/437)
>
> 给出一个有向图，找一条恰好经过 k 个点的最短路径，要求每次选的边不能跃过之前已经经过的节点。即对于路径中的边 x→y ,不存在以前经过的点 t 使得三者的编号满足 min(x,y) ≤ t ≤ max(x,y)。
>
> #### 输入格式
>
> 第一行三个数字 n,k,m。
>
> 接下来m行 , 每行 3 个整数 ai,bi,ci表示存在一条从 ai→bi , 长度为 ci 的有向边。
>
> #### 输出格式
>
> 一个数，表示答案。如果不存在任何一条路径满足条件，则输出 −1。

解题思路：

> 拿到题目，首先是畏惧感，这可是*2100的题目，硬生生的害怕，然后心里想着一定要跟上div1，于是开始思考。
>
> 最开始的思路是，枚举每个点作为起点，然后往后做一个特殊版本的bellman-ford算法，控制条件加一维度——“每次选的边不能跃过之前已经经过的节点”
>
> 最后想到最后，自闭了，是在不知道怎么讨论，于是去求助了大佬，沃老师在视频中给了提示：[视频地址](https://www.bilibili.com/video/BV1h44y1n7Fd)
>
> 得知这个题可以使用区间dp来解。
>
> 使用`f[110][110][110][2]`来作为dp数组，使用`f[s][i][j][c]`来表示在区间`[i, j]`中，经过了s条满足条件的边，并且**起始点**在在c位置（c位置有两个值，0表示最后停留在`i`位置，1表示最终停留在`j`位置），数组值记录当前状态的最短路长度。
>
> 根据题目给定特殊限制，我们知道在一个区间内部，我们从一个端点出发，可以走到这个端点的出边，也就可以使用这个出边点的状态来更新当前状态。
>
> 假设我们在讨论区间 `[i, j]`：
>
>  对于`f[s][i][j][0]`， 我们是从`i`点出发，假设有`i`的出边点`x`，满足`i < u < j` 则我们可以从`i`点首先移动到`x`号点，然后在从`x`点出发，在区间`(x, j)`里面有s-1条边，得到的状态转移方程为:
>
> `f[s][i][j][0] = min(f[s][i][j][0], f[s-1][i][x][1] + y)`
>
> `f[s][i][j][0] = min(f[s][i][j][0], f[s-1][x][j][0] + y)`
>
> ，其中y为`i`到`x`的距离。请注意这里面最后一维度的0和1。
>
> 对于`f[s][i][j][1]`的更新同理，最后转移方程为：
>
> `f[s][i][j][1] = min(f[s][i][j][1], f[s-1][i][x][1] + y)`
>
> `f[s][i][j][1] = min(f[s][i][j][1], f[s-1][x][j][0] + y)`
>
> 下面来介绍代码实现：
>
> 一、使用邻接表来存储边，（时间效益上优于暴力）
>
> 二、枚举当前所在考虑的边，从第一条边开始
>
> 三、枚举左端点，这里需要注意，我们在更新某一段区间的时候，需要保证它的子区间都被更新过，从而才能更新当前区间，所以左端点从大到小枚举
>
> 四、枚举右端点，右区间从左端点的下一个点开始枚举
>
> 五、开始对当前区间的所有信息开始更新。
>
> 六、最后汇总所有的路线为k个点的值，取min，就是最后的答案，如果为inf，则无答案，反之可以有答案。
>
> 小tips：这里在枚举的时候，我们考虑了`(0, n+1)`号点，因为假设我们只考虑区间`(1, n)` 那么如果`1`到`n`之间有边，这个边将永远不会使用，所以我们需要一个方式来衡量是否使用了所有的数据，我们往前往后动一个点，则在枚举两端的点的时候能够使用到所有的边。

```c++
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using pii = pair<int, int>;

const int N = 110, inf = 0x3f3f3f3f;
int f[N][N][N][2];//最后一维度是“跳之前”在什么位置
vector<pii> edge[N];

int main(){
	int n, k, m; cin >> n >> k >> m;

	//存图，两个点之间的距离，有向边，当没有边的时候取inf
	for(int i = 0; i < m; i ++){
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		edge[a].push_back({b, c});//建立邻接表
	}

	//开始dp
	for(int s = 1; s < k; s ++){//枚举边的数量
		for(int i = n; i >= 0; i --){//区间左端点,左边和右边开大一维最后
			for(int j = i+1; j <= n+1; j ++){//区间右端点
				// 更新左边
				f[s][i][j][0] = inf;
				for(auto tmp : edge[i]){
					int x = tmp.first, y = tmp.second;
					if(x > i && x < j)
						f[s][i][j][0] = min(f[s][i][j][0], f[s-1][i][x][1] + y),
						f[s][i][j][0] = min(f[s][i][j][0], f[s-1][x][j][0] + y);
				}
				//更新右边
				f[s][i][j][1] = inf;
				for(auto tmp : edge[j]){
					int x = tmp.first, y = tmp.second;
					if(x > i && x < j)
						f[s][i][j][1] = min(f[s][i][j][1], f[s-1][i][x][1] + y),
						f[s][i][j][1] = min(f[s][i][j][1], f[s-1][x][j][0] + y);
				}
			}
		}
	}

	//最后需要找到走了k个点的最小解
	int ans = inf;
	for(int i = 1; i <= n; i ++)//最后停留在i点
		ans = min(ans, f[k-1][0][i][1]),
		ans = min(ans, f[k-1][i][n+1][0]);

	cout << (ans == inf ? -1 : ans) << endl;
	return 0;
}	

```

