题面：[daimayuan](http://oj.daimayuan.top/course/10/problem/456)

>给定N个正整数a1,a2,…,an 。 要求从其中选出若干数字, 使得这些数字的和 mod N=0 (对于每个下标最多只能选择一次)。
>
>#### 输入格式
>
>第一行一个数字N, 表示数字个数。
>
>接下来一行 N 个整数 a1,a2,…,an , 表示这N个数。
>
>#### 输出格式
>
>第一行输出M, 表示选择的数的个数。
>
>第二行输出M个正整数, 用空格隔开, 表示这些数字的下标。
>
>如果有多种方案满足要求, 输出任意一种。
>
>如果没有满足要求的方案 输出 −1。
>
>#### 数据规模
>
>所有数据保证 1≤N≤100000,1≤ai≤109 。

思维历程：

>*1700题目，感觉可以冲一下（自以为是），看完题面之后，我顿悟，这不是可以使用记录路径的dp做嘛，用每个元素，枚举值域来更新所有状态（康哥曾经教我的），然后我就开始祈祷数据范围不要超过1000级别，一度以为自己可以冲击1700分了，看了数据范围之后，woc！五次方级别，我人傻了，这种时间复杂度只能通过线性或者加一个log来做，这尼玛怎么搞嘛，调整思路，开始思考怎么个dp法子（事实证明满脑子dp不是一个明智的选择），首先记录路径的dp肯定行不通，通常能够记录路径的dp前提条件是值域比较小，能够枚举值域来dp。然后满脑子都是怎么记录背包路径，不太行，思考到题目的性质，需要找到N的倍数，于是从第一个数开始，用每一个数来更新前面的所有出现过的数，由于值域只有100000，所以数组只需要开辟100000即可，但是推导到后面，时间变成了n方级别，还不能记录路径，麻了。思考许久，想出以下状态表示：
>
>`f[i]` : 当前组合的和为`i`（取模后）,当前组合的最后一个参与元素位置为`f[i]`，于是假设我们得到了i为0的方案，我们能够找到最后出现的元素的位置，假设当前位置数为`w[f[i]]`，然后再通过`f[i-w[f[i]]]`找到前一个位置，知道取到第一个数为止，思路貌似可行，开始证明：
>
>我们这个方案的前提是通过`f[i-w[f[i]]]`一定在前面更新过，因为不能使用一个位置的元素两次。而且`f[i-w[f[i]]]`的组合不止一个，换言之这个值可以有很多位置，我们这里取最前面的一个位置，这样能够保证在dp的过程中不会使用重复的位置，所以我自以为是的给出了一套dp转移方式：
>
>我们第一维度来枚举值域（这里的值域是指给出的数组的补集，因为给出了的可以直接使用），在思考第二维度的时候犯难了，想要枚举数组，但是要是补集过于大，直接炸裂，而且我发现上面的思路并不能避免重复使用这个问题，简单来说，后面直接出现的数字可能可以通过前面的数字组合得到，最后证明这个思路不可行（我想不出来了，因为这种方案最少有两重循环，而平均时间很容易被卡，补集很大的时候）。
>
>所以最后开始不得已去看了wls的简单提示，woc，茅塞顿开。。
>
>wls给出的思路是：前缀和+抽屉原理。我们求前缀和，然后前缀和中有重复的元素的话，两个重复元素中间的点的和就一定是n的倍数，（额~ 似曾相识的感觉，好像之前也写过类似的题面，前缀和相等，中间的元素满足某些性质）……到这里，我就悟了，知道思路之后1700题目直接变成800题目……

反思：

>拿到题目的时候，应该看到数据范围之后，经过简单的思考立即放弃dp的想法，挖掘为什么给了n个数，还需要找出是n的倍数的方案，能想到这里应该就大概率能得出解了吧，抽屉原理直接解决。
>
>思考以下，最后要是不是求n的倍数，而是n+1的倍数，则使用前缀和统计的时候就需要找差值为n+1的倍数的方案，相反就复杂起来。当要求的是n-1的倍数，同样复杂起来。所以应该能想到容斥的，抽屉的基础是，因为前缀和的值最多有n种方案，而当没有达到n个方案时，就一定有两个位置的相等的，当有n个方案时，就一定存在一个为0的方案，直接0这个位置前面所有数相加即可。而如上面所说，如果是求n-1或者n+1的倍数，那就可以n没有什么关系了，可能最后还是需要dp吧，但是可以基于前缀和的思路进行优化：求出前缀和，然后找出后面有没有一个数和当前数做差，为n+1的倍数…… 额，右变成n方，还不保证能找出解，当一个合适的都没有的话，不能保证一定存在0的方案，这里想不清楚了，可能是dp做少了吧。

给出代码：

```c++
#include <bits/stdc++.h>

using namespace std;

map<int, int> mp;
int pre, x;

int main(){
	int n; cin >> n;
	mp[0] = 0;
	for(int i = 1; i <= n; i ++){
		scanf("%d", &x);
		pre = (pre + x) % n;
		if(mp.find(pre) == mp.end()) mp[pre] = i;
		else{
			printf("%d\n", i-mp[pre]);
			for(int j = mp[pre]+1; j <= i; j ++) printf("%d ", j);
			return 0;
		}
	}
	printf("%d\n", n);
	for(int i = 1; i <= n; i ++) printf("%d ", i);
	return 0;
}
```

